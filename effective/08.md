## `别让异常逃离析构函数`

> Prevent exceptions from leaving destructors

`C++`并不禁止析构函数吐出异常，但它不鼓励这样做。这是有理由的，考虑以下代码：
```
class Widget {
 public:
  ~Widget() { ... }            // assume this might emit an exception
};
void doSomething(){
  std::vector<Widget> v;
}                              // v is automatically destroyed here
```
当 `vector v`被销毁，它有责任销毁其内含的所有 `widgets`。假设`v`内含`十个widgets`，而在析构第一个元素期间，有个异常被抛出。其他`九个 widgets` 还是应该被销毁(否则它们保存的任何资源都会发生泄漏)，因此应该调用它们各个析构函数。但假设在那些调用期间，第二个 `widget` 析构函数又抛出异常。现在有两个同时作用的异常，这对 `C++` 而言太多了。在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确行为。本例中它会导致不明确的行为。使用标准程序库的任何其他容器(如`list set`)或`TR1`的任何容器(条款54)或甚至`array`，也会出现相同情况。`容器或array` 并非遇上麻烦的必要条件，只要析构函数吐出异常，即使并非使用`容器或 arrays`，程序也可能过早结束或出现不明确行为。是的，`C++` 不喜欢析构函数吐出异常!

这很容易理解，如果你的析构函数必须执行一个动作，而该动作可能在失败时抛出异常，该怎么办？
一个较佳策略是重新设计 `DBConn` 接口，使其客户有机会对可能出现的问题作出反应。例如 `DBConn`自己可以提供一个 `close`函数，因而赋予客户一个机会得以处理"因该操作而发生的异常"。`DBConn` 也可以追踪其所管理之 `DBConnection` 是否已被关闭，并在答案为否的情况下由其析构函数关闭之。这可防止遗失数据库连接。然而如果`DBConnection`析构函数调用`close`失败，我们又将退回"强迫结束程序或"吞下异常"的老路:
#### `之所以如此，是为了：`
- 析构函数里不抛出异常，如果真有，就吞下；
- 提供接口由客户显示清理，如有异常，交给客户处理；
```
class DBConn {
 public:
  ...
  void close() {
    db.close();
    closed = true;
  }
  ~DBConn() {
    if (!closed) {
      try {
        db.close();
      } catch (...) {
        制作流转记录，记下对close的调用失败
        ...
      }
    }
  }
 private:
  DBConnection db;
  bool closed;
};
```
把调用`close`的责任从`DBConn`析构函数手上转移到`DBConn`客户手上(但`DBConn`析构函数仍内含一个`双保险`调用)。
如果某个操作可能在失败的时候抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。
因为析构函数吐出异常就是危险，总会带来`过早结束程序`或`发生不明确行为`的风险。本例要说的是，由客户自己调用 `close` 并不会对他们带来负担，而是给他们一个处理错误的机会，否则他们没机会响应。如果他们不认为这个机会有用(或许他们坚信不会有错误发生)可以忽略它，倚赖`DBConn` 析构函数去调用 `close`。如果真有错误发生一如果`close`的确抛出异常一-而且 `DBConn`吞下该异常或结束程序，客户没有立场抱怨，毕竟他们曾有机会第一手处理问题，而他们选择了放弃。

#### `请记住`
- 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序
- 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 `class`` 应该提供一个普通函数(而非在析构函数中)执行该操作