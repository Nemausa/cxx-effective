## `以对象管理资源`
> Use objects to manage resources

假设我们使用一个用来塑模投资行为(例如股票、债券等等)的程序库，其中各式各样的投资类型继承自一个`root class Investment`
```
Investment *pInv = createInvestment();
...
delete pInv;
```
这看起来妥当，但若干情况下`f`可能无法删除它得自`createInvestment` 的投资对象一一或许因为`"..."`区域内的一个过早的`return`语句。如果这样一个 `return`被执行起来，控制流就绝不会触及 `delete` 语句。

类似情况发生在对`createInvestment` 的使用及 `delete` 动作位于某循环内，而该循环由于某个`continue`或 `goto`语句过早退出。最后一种可能是`"..."`区域内的语抛出异常果真如此控制流将再次不会幸临 `delete`。无论 `delete` 如何被略过去，我们泄漏的不只是内含投资对象的那块内存，还包括那些投资对象所保存的任何资源。

当然啦，谨慎地编写程序可以防止这一类错误，但你必须想想，代码可能会在时间渐渐过去后被修改。一旦软件开始接受维护，可能会有某些人添加 `return`语句或 `continue` 语句而未能全然领悟它对函数的资源管理策略造成的后果。更糟的是的`"..."`区域有可能调用一个**过去从未抛出异常，却在被'改善'之后开始那么做的函数**。因此单纯倚赖**f 总是会执行其 delete语句**是行不通的

为确保 `createInvestment` 返回的资源总是被释放，我们需要将资源放进对象内，当控制流离开 `f`，该对象的析构函数会自动释放那些资源。实际上这正是隐身于本条款背后的半边想法: 把资源放进对象内，我们便可赖 `C++` 的**析构函数自动调用机制**`确保资源被释放。

幸运的是，我们可以用对象来包装资源，并在析构函数中释放它。这样客户便不需要维护资源的内存了。 `std::shared_ptr` 便是这样一个对象，它被称为智能指针（`smart pointer`）。 典型的使用场景是资源在堆空间中存储但只在局部被使用：

```
void f(){
  std::shared_ptr<Investment> pInv(createInvestment());
}
```

在`f()`调用结束时`pInv`退出作用域，析构函数被调用，最终使得资源被释放。 事实上，让`createInvestment`直接返回智能指针是更好的设计。 可以看到，使用对象来管理资源的关键在于：**创建资源后立即放入资源管理对象中，并利用资源管理对象的析构函数来确保资源被释放**。